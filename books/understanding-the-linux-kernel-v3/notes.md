深入理解Linux内核（第三版）

# 第一章 概述

本章简单介绍了一下Linux内核，并与其他Unix内核做了简单的对比。最后，对一些Unix/Linux的基本知识，进行了简要概述。

## linux 介绍

## 操作系统基本概念
* 操作系统的目标
* 多用户系统
* 用户和用户组
* 进程
* unix/linux内核体系结构

## UNIX文件系统概述
* 文件及其组织（目录树）
* 硬链接和软链接
* 文件类型
* 文件描述符和索引节点
* 访问权限
* 文件操作的系统调用
  * open()
  * read() / write()
  * lseek()
  * close()
  * rename() / unlink()

## UNIX内核概述
* 内核模式
* 进程与进程实现
* 可重入内核：若干个进程可同时在内核态下执行。
* 进程地址空间
* 同步和临界区
  * 非抢占式内核
  * 禁止中断
  * 信号量 / 自旋锁
  * 避免死锁
* 信号和进程间通信
* 进程管理
  * 僵尸进程
  * 进程组和登录会话
* 内存管理
  * 虚拟内存
  * 随机访问存储器（RAM）
  * 内核内存分配器
  * 进程虚拟地址空间处理
  * 高速缓存
* 设备驱动程序

# 第二章 内存寻址

本章将详细讲述80x86微处理器怎样进行芯片级的内存寻址，Linux又是如何利用寻址硬件的。

首先引出了80x86的段页式内存管理，然后依次介绍了[硬件中的分段](#硬件中的分段)、[Linux中的分段](#linux中的分段)、[硬件中的分页](#硬件中的分页)、[Linux中的分页](#linux中的分页)。

## 内存地址

内存地址分类：
* 逻辑地址：段+偏移量组成。
* 线性地址，即虚拟地址，一个32位无符号整数，表示高达4GB的地址空间。
* 物理地址，用于内存芯片级内存单元寻址。

转换管理：MMU的分段单元，将逻辑地址转换为线性地址。分页单元将线性地址转换为物理地址。

## 硬件中的分段

从80286开始，分为实模式和保护模式。实模式主要是为了与早期的处理器兼容，下面主要介绍保护模式。

### 段选择符和段寄存器

一个逻辑地址由段选择符（16位）和段内偏移（32位）组成。段选择符存储在段寄存器中。80x86提供了6个段寄存器：
* cs：代码段寄存器，指向包含程序指令的段。
* ss：栈段寄存器，指向包含当前程序栈的段。
* ds：数据段寄存器，指向包含静态数据或者全局数据段。
* es fs gs：一般用途，可以指向任意段。

### 段描述符

每个段通过一个`8B`大小的`段描述符`来描述特征。段描述符存储在全局描述符表（GDT）或局部描述符表（LDT）中。GDT通常只有一个；如果进程创建了GDT中没有的段，就拥有自己的LDT。GDT的地址和大小存放在`gdtr`控制寄存器，LDT的地址和大小存放在`ldtr`控制寄存器。

段描述符字段及其含义：暂略。

### 快速访问段描述符

为每个段寄存器提供了一个非编程寄存器，当段寄存器内容发送变化时，将从LDT或GDT中加载对应的段描述符到对应的非编程寄存器。

段寄存器存储了段描述符在描述符表中的索引。

### 分段单元

分段单元负责将逻辑地址转换为线性地址。转换步骤如下：
1. 检查段选择符中的TI字段，决定段描述符保存在哪一个描述符表中（GDT or LDT）。
2. 从段选择符的index字段计算出段描述符的地址。
3. 将逻辑地址的偏移量与段描述符Base字段的值相加，得到线性地址。

注：由于非编程寄存器的存在，如果段寄存器的内容没有发生变化，第1、2步可以省略。

## Linux中的分段

Linux以非常有限的方式使用了分段，更倾向于使用分页。Linux2.6 只在80x86上使用了分段。

用户态的所有进程，都通过`用户代码段(__USER_CS)`和`用户数据段(__USER_DS)`来寻址代码和数据。内核态的所有进程，都通过`内核代码段(__KERNEL_CS)`和`内核数据段(__KERNEL_DS)`来寻址代码和数据。

四个段都是从0x0开始，即Linux下，逻辑地址和线性地址是一致的。

CPU 的特权等级发生变化时（用户态 <--> 内核态），相应的段寄存器也要更新。

### Linux GDT

单处理器系统中只有一个GDT，多处理器系统每个CPU都有一个GDT。所有的GDT存放在`cpu_gdt_table`数组中，所有GDT的地址和大小存放在`cpu_gdt_descr`数组中。

GDT中每个段的详细说明：暂略。

### Linux LDT

大多数应用程序不需要LDT，所以Linux定义了一个缺省的LDT供所有的应用程序共享，即`default_ldt`数组，包含5个项。

应用程序也可以使用`modify_ldt()`系统调用，创建自己的LDT。

## 硬件中的分页

将线性地址分成固定长度单位的组，称为`页`。将RAM分成固定长度单位的`页框`，每个页框包含一个页。注意区分页和页框，页指一个数据块，可以存放在任意页框或磁盘中。

`分页单元`负责将线性地址转换为物理地址。把线性地址映射到物理地址的数据结构称为`页表`，存放在主存中。在启用分页单元之前，由内核负责初始化。

### 常规分页

从80386开始，分页单元处理4KB分页。

32位线性地址被分为3个部分：
1. 页目录索引，最高10位，立即分配。
2. 页表索引，中间10位，按需分配。
3. 页内偏移，低12位。

使用这种二级模式，是为了减少进程页表所需要的RAM空间。

页目录的地址存放在控制寄存器cr3。线性地址到物理地址的转换分为两步，第一步通过页目录索引，寻找到页表的基地址；第二步通过页表索引，找到页基地址。页基地址加上页内偏移，即得到了物理地址。

页目录项和页表项包含相同的内容，详细说明如下：暂略。

### 扩展分页

从Pentium开始，引入了扩展分页。简单来说，页框从4KB变为4MB，两级索引变为一级索引。32位线性地址分为2部分：
1. 页目录索引，最高10位。
2. 页内偏移，低22位。

### 硬件保护方案

页表和页的权限。

### 常规分页举例

暂略。

### 物理地址扩展（PAE）分页机制

当物理地址总线从32位扩展到36位时，32位线性地址空间无法寻址所有的物理地址，必须修改分页机制，将32位线性地址空间转换为36位物理地址。

主要的改变：
1. 64GB RAM分为$2^{24}$个页框，页表项大小从32位变为64位。
2. 引入页目录指针表（PDPT）
3. 线性地址映射到4KB的页时，32位地址按照如下方式解释：
   1. CR3 指向一个PDPT
   2. 位31 - 30 ：PDPT 索引
   3. 位29 - 21 ：页目录索引
   4. 位20 - 12 ：页表索引
   5. 位11 -  0 ：页内偏移
4. 线性地址映射到2MB的页时，32位地址按照如下方式解释：
   1. CR3 指向一个PDPT
   2. 位31 - 30 ：PDPT索引
   3. 位29 - 21 ：页目录索引
   4. 位20 -  0 ：页内偏移

### 64位系统中的分页

由于64位线性地址空间过于庞大，两级分页会有页目录表过于庞大的问题，所以两级分页不适用于64位系统。64位系统一般采用三级甚至四级分页。

### 硬件高速缓存

因为CPU的速度是DRAM的几十倍，甚至上百倍。为了缩小CPU和DRAM之间的速度差异，基于局部性原理，在CPU和DRAM之间放置了硬件高速缓存。关于更加详细的内容，可以参考组成原理或体系结构的书籍。

引入硬件高速缓存后，以下两个问题必须考虑：
1. 缓存和DRAM的数据同步。
2. 多处理器缓存之间的数据同步。

### 转换后援缓冲器（TLB）

TLB独立于通用的硬件高速缓存，用于加速线性地址到物理地址的转换。当TLB没有命中时，需要访问主存读取页表，并在TLB中增加一项。当下次访问同一页的线性地址时，无需访问主存，直接从TLB读取基地址。

## Linux中的分页

### 线性地址字段

### 页表处理

### 物理内存布局

### 进程页表

### 内核页表

### 固定映射的线性地址

### 处理硬件高速缓存和TLB